
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta charset="utf-8" />
    <title>kicost.edas.tools &#8212; kicost 1.1.3 documentation</title>
    <link rel="stylesheet" href="../../../_static/classic.css" type="text/css" />
    <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript" id="documentation_options" data-url_root="../../../" src="../../../_static/documentation_options.js"></script>
    <script type="text/javascript" src="../../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../../_static/doctools.js"></script>
    <script type="text/javascript" src="../../../_static/language_data.js"></script>
    
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 
  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../../index.html">kicost 1.1.3 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../../index.html" accesskey="U">Module code</a> &#187;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for kicost.edas.tools</h1><div class="highlight"><pre>
<span></span><span class="c1"># -*- coding: utf-8 -*- </span>
<span class="c1"># MIT license</span>
<span class="c1">#</span>
<span class="c1"># Copyright (C) 2018 by XESS Corporation / Hildo Guillardi Júnior</span>
<span class="c1">#</span>
<span class="c1"># Permission is hereby granted, free of charge, to any person obtaining a copy</span>
<span class="c1"># of this software and associated documentation files (the &quot;Software&quot;), to deal</span>
<span class="c1"># in the Software without restriction, including without limitation the rights</span>
<span class="c1"># to use, copy, modify, merge, publish, distribute, sublicense, and/or sell</span>
<span class="c1"># copies of the Software, and to permit persons to whom the Software is</span>
<span class="c1"># furnished to do so, subject to the following conditions:</span>
<span class="c1">#</span>
<span class="c1"># The above copyright notice and this permission notice shall be included in</span>
<span class="c1"># all copies or substantial portions of the Software.</span>
<span class="c1">#</span>
<span class="c1"># THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR</span>
<span class="c1"># IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,</span>
<span class="c1"># FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE</span>
<span class="c1"># AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER</span>
<span class="c1"># LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,</span>
<span class="c1"># OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN</span>
<span class="c1"># THE SOFTWARE.</span>

<span class="c1"># Author information.</span>
<span class="n">__author__</span> <span class="o">=</span> <span class="s1">&#39;Hildo Guillardi Júnior&#39;</span>
<span class="n">__webpage__</span> <span class="o">=</span> <span class="s1">&#39;https://github.com/hildogjr/&#39;</span>
<span class="n">__company__</span> <span class="o">=</span> <span class="s1">&#39;University of Campinas - Brazil&#39;</span>

<span class="c1"># Libraries.</span>
<span class="kn">import</span> <span class="nn">re</span><span class="o">,</span> <span class="nn">os</span> <span class="c1"># Regular expression parser and matches.</span>
<span class="kn">from</span> <span class="nn">..global_vars</span> <span class="k">import</span> <span class="o">*</span> <span class="c1"># Debug, language and default configurations.</span>
<span class="kn">from</span> <span class="nn">..distributors.global_vars</span> <span class="k">import</span> <span class="n">distributor_dict</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="k">import</span> <span class="n">eda_dict</span> <span class="c1"># EDA dictionary with the features.</span>

<span class="n">__all__</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;file_eda_match&#39;</span><span class="p">,</span> <span class="s1">&#39;partgroup_qty&#39;</span><span class="p">,</span> <span class="s1">&#39;groups_sort&#39;</span><span class="p">,</span> <span class="s1">&#39;order_refs&#39;</span><span class="p">,</span> <span class="s1">&#39;subpartqty_split&#39;</span><span class="p">,</span> <span class="s1">&#39;group_parts&#39;</span><span class="p">]</span>

<span class="c1"># Qty and part separators are escaped by preceding with &#39;\&#39; = (?&lt;!\\)</span>
<span class="n">QTY_SEPRTR</span>  <span class="o">=</span> <span class="sa">r</span><span class="s1">&#39;(?&lt;!</span><span class="se">\\</span><span class="s1">)\s*[:]\s*&#39;</span>  <span class="c1"># Separator for the subpart quantity and the part number, remove the lateral spaces.</span>
<span class="n">PART_SEPRTR</span> <span class="o">=</span> <span class="sa">r</span><span class="s1">&#39;(?&lt;!</span><span class="se">\\</span><span class="s1">)\s*[;,]\s*&#39;</span> <span class="c1"># Separator for the part numbers in a list, remove the lateral spaces.</span>
<span class="n">ESC_FIND</span> <span class="o">=</span> <span class="sa">r</span><span class="s1">&#39;</span><span class="se">\\</span><span class="s1">\s*([;,:])\s*&#39;</span>      <span class="c1"># Used to remove backslash from escaped qty &amp; manf# separators.</span>
<span class="n">REPLICATE_MANF</span> <span class="o">=</span> <span class="s1">&#39;~&#39;</span> <span class="c1"># Character used to replicate the last manufacture name (`manf` field) in multi-parts.</span>
<span class="n">SGROUP_SEPRTR</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span> <span class="c1"># Separator of the semi identical parts groups (parts that have the filed ignored to group).</span>
<span class="n">PRJ_STR_DECLARE</span> <span class="o">=</span> <span class="s1">&#39;prj&#39;</span> <span class="c1"># Project string declaration attached to the beginning of each reference correspondent to one project in the multi-project files case.</span>
<span class="n">PRJPART_SPRTR</span> <span class="o">=</span> <span class="n">SEPRTR</span> <span class="c1"># Separator between part designator and reference string. `PRJ_STR_DECLARE` + \d + `PRJPART_SPRTR` + ref</span>
<span class="c1"># Control for the group-collapse presentation.</span>
<span class="n">PART_SEQ_SEPRTR</span>  <span class="o">=</span> <span class="s1">&#39;-&#39;</span> <span class="c1"># Part separator for sequential grouping.</span>
<span class="n">PART_NSEQ_SEPRTR</span>  <span class="o">=</span> <span class="s1">&#39;,&#39;</span> <span class="c1"># Part separator for non-sequential grouping.</span>
<span class="n">SUB_SEPRTR</span>  <span class="o">=</span> <span class="s1">&#39;#&#39;</span> <span class="c1"># Subpart separator for a part reference.</span>
<span class="n">PRJ_SEPRTR</span> <span class="o">=</span> <span class="s1">&#39;;&#39;</span> <span class="c1"># Separator between projects when collapsed and grouped the part references.</span>
<span class="c1"># Reference string order to the spreadsheet. Use this to</span>
<span class="c1"># group the elements in sequential rows.</span>
<span class="n">BOM_ORDER</span> <span class="o">=</span> <span class="s1">&#39;u,q,d,t,y,x,c,r,s,j,p,cnn,con&#39;</span>

<span class="c1"># Characters removed from references when read the files.</span>
<span class="n">PART_REF_REGEX_NOT_ALLOWED</span> <span class="o">=</span> <span class="s1">&#39;[\+\(\)\*\</span><span class="si">{}</span><span class="s1">]&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">SEPRTR</span><span class="p">)</span>
<span class="c1"># Regular expression for detecting part reference ids consisting of a</span>
<span class="c1"># prefix of letters followed by a sequence of digits, such as &#39;LED10&#39;</span>
<span class="c1"># or a sequence of digits followed by a subpart number like &#39;CONN1#3&#39;.</span>
<span class="c1"># There can even be an interposer alphabetical and some special</span>
<span class="c1"># characters so &#39;LED.10&#39;, &#39;LED_10&#39;, &#39;LED_BLUE-10&#39;, &#39;TEST&amp;PIN+2&#39;,</span>
<span class="c1"># &#39;TEST+SUPPLY&#39; or &#39;R4.10&#39; is also OK.</span>
<span class="c1"># Also references with numbers at the end, just if the interlocutor,</span>
<span class="c1"># part are allowed by some EDAs or manual edition in KiCad.</span>
<span class="c1"># In the case of multiple project BOM files, the references are</span>
<span class="c1"># modified by adding the project number identification followed</span>
<span class="c1"># by `SEPRTR` definition.</span>
<span class="n">PART_REF_REGEX_SPECIAL_CHAR_REF</span> <span class="o">=</span> <span class="s1">&#39;\+\-\=\s\_\.\(\)\$\*\&amp;&#39;</span> <span class="c1"># Used in next definition only (because repeat).</span>
<span class="n">PART_REF_REGEX</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="s1">&#39;(?P&lt;prefix&gt;(</span><span class="si">{p_str}</span><span class="s1">(?P&lt;prj&gt;\d+)</span><span class="si">{p_sp}</span><span class="s1">)?(?P&lt;ref&gt;[a-z</span><span class="si">{sc}</span><span class="s1">\d]*[a-z</span><span class="si">{sc}</span><span class="s1">]))(?P&lt;num&gt;((?P&lt;ref_num&gt;\d+(\.\d+)?)(</span><span class="si">{sp}</span><span class="s1">(?P&lt;subpart_num&gt;\d+))?)?)&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">p_str</span><span class="o">=</span><span class="n">PRJ_STR_DECLARE</span><span class="p">,</span> <span class="n">p_sp</span><span class="o">=</span><span class="n">PRJPART_SPRTR</span><span class="p">,</span>
                                <span class="n">sc</span><span class="o">=</span><span class="n">PART_REF_REGEX_SPECIAL_CHAR_REF</span><span class="p">,</span> <span class="n">sp</span><span class="o">=</span><span class="n">SUB_SEPRTR</span><span class="p">),</span> <span class="n">re</span><span class="o">.</span><span class="n">IGNORECASE</span><span class="p">)</span>

<span class="c1"># Generate a dictionary to translate all the different ways people might want</span>
<span class="c1"># to refer to part numbers, vendor numbers, manufacture name and such.</span>
<span class="n">field_name_translations</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s1">&#39;mpn&#39;</span><span class="p">:</span> <span class="s1">&#39;manf#&#39;</span><span class="p">,</span>
    <span class="s1">&#39;pn&#39;</span><span class="p">:</span> <span class="s1">&#39;manf#&#39;</span><span class="p">,</span>
    <span class="s1">&#39;manf_num&#39;</span><span class="p">:</span> <span class="s1">&#39;manf#&#39;</span><span class="p">,</span>
    <span class="s1">&#39;manf-num&#39;</span><span class="p">:</span> <span class="s1">&#39;manf#&#39;</span><span class="p">,</span>
    <span class="s1">&#39;mfg_num&#39;</span><span class="p">:</span> <span class="s1">&#39;manf#&#39;</span><span class="p">,</span>
    <span class="s1">&#39;mfg-num&#39;</span><span class="p">:</span> <span class="s1">&#39;manf#&#39;</span><span class="p">,</span>
    <span class="s1">&#39;mfg#&#39;</span><span class="p">:</span> <span class="s1">&#39;manf#&#39;</span><span class="p">,</span>
    <span class="s1">&#39;mfg part#&#39;</span><span class="p">:</span> <span class="s1">&#39;manf#&#39;</span><span class="p">,</span>
    <span class="s1">&#39;man_num&#39;</span><span class="p">:</span> <span class="s1">&#39;manf#&#39;</span><span class="p">,</span>
    <span class="s1">&#39;man-num&#39;</span><span class="p">:</span> <span class="s1">&#39;manf#&#39;</span><span class="p">,</span>
    <span class="s1">&#39;man#&#39;</span><span class="p">:</span> <span class="s1">&#39;manf#&#39;</span><span class="p">,</span>
    <span class="s1">&#39;mnf_num&#39;</span><span class="p">:</span> <span class="s1">&#39;manf#&#39;</span><span class="p">,</span>
    <span class="s1">&#39;mnf-num&#39;</span><span class="p">:</span> <span class="s1">&#39;manf#&#39;</span><span class="p">,</span>
    <span class="s1">&#39;mnf#&#39;</span><span class="p">:</span> <span class="s1">&#39;manf#&#39;</span><span class="p">,</span>
    <span class="s1">&#39;mfr_num&#39;</span><span class="p">:</span> <span class="s1">&#39;manf#&#39;</span><span class="p">,</span>
    <span class="s1">&#39;mfr-num&#39;</span><span class="p">:</span> <span class="s1">&#39;manf#&#39;</span><span class="p">,</span>
    <span class="s1">&#39;mfr#&#39;</span><span class="p">:</span> <span class="s1">&#39;manf#&#39;</span><span class="p">,</span>
    <span class="s1">&#39;part-num&#39;</span><span class="p">:</span> <span class="s1">&#39;manf#&#39;</span><span class="p">,</span>
    <span class="s1">&#39;part_num&#39;</span><span class="p">:</span> <span class="s1">&#39;manf#&#39;</span><span class="p">,</span>
    <span class="s1">&#39;p#&#39;</span><span class="p">:</span> <span class="s1">&#39;manf#&#39;</span><span class="p">,</span>
    <span class="s1">&#39;part#&#39;</span><span class="p">:</span> <span class="s1">&#39;manf#&#39;</span><span class="p">,</span>
    <span class="s1">&#39;manf&#39;</span><span class="p">:</span> <span class="s1">&#39;manf&#39;</span><span class="p">,</span>
    <span class="s1">&#39;manufacturer&#39;</span><span class="p">:</span> <span class="s1">&#39;manf&#39;</span><span class="p">,</span>
    <span class="s1">&#39;mnf&#39;</span><span class="p">:</span> <span class="s1">&#39;manf&#39;</span><span class="p">,</span>
    <span class="s1">&#39;man&#39;</span><span class="p">:</span> <span class="s1">&#39;manf&#39;</span><span class="p">,</span>
    <span class="s1">&#39;mfg&#39;</span><span class="p">:</span> <span class="s1">&#39;manf&#39;</span><span class="p">,</span>
    <span class="s1">&#39;mfr&#39;</span><span class="p">:</span> <span class="s1">&#39;manf&#39;</span><span class="p">,</span>
<span class="p">}</span>
<span class="c1"># Create the fields translate for each distributor submodule.</span>
<span class="k">for</span> <span class="n">stub</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;part#&#39;</span><span class="p">,</span> <span class="s1">&#39;#&#39;</span><span class="p">,</span> <span class="s1">&#39;p#&#39;</span><span class="p">,</span> <span class="s1">&#39;pn&#39;</span><span class="p">,</span> <span class="s1">&#39;vendor#&#39;</span><span class="p">,</span> <span class="s1">&#39;vp#&#39;</span><span class="p">,</span> <span class="s1">&#39;vpn&#39;</span><span class="p">,</span> <span class="s1">&#39;num&#39;</span><span class="p">]:</span>
    <span class="k">for</span> <span class="n">dist</span> <span class="ow">in</span> <span class="n">distributor_dict</span><span class="p">:</span>
        <span class="n">field_name_translations</span><span class="p">[</span><span class="n">dist</span> <span class="o">+</span> <span class="n">stub</span><span class="p">]</span> <span class="o">=</span> <span class="n">dist</span> <span class="o">+</span> <span class="s1">&#39;#&#39;</span>
        <span class="n">field_name_translations</span><span class="p">[</span><span class="n">dist</span> <span class="o">+</span> <span class="s1">&#39;_&#39;</span> <span class="o">+</span> <span class="n">stub</span><span class="p">]</span> <span class="o">=</span> <span class="n">dist</span> <span class="o">+</span> <span class="s1">&#39;#&#39;</span>
        <span class="n">field_name_translations</span><span class="p">[</span><span class="n">dist</span> <span class="o">+</span> <span class="s1">&#39;-&#39;</span> <span class="o">+</span> <span class="n">stub</span><span class="p">]</span> <span class="o">=</span> <span class="n">dist</span> <span class="o">+</span> <span class="s1">&#39;#&#39;</span>

<span class="c1"># Others fields used by KiCost and that have to be standardized.</span>
<span class="n">field_name_translations</span><span class="o">.</span><span class="n">update</span><span class="p">(</span>
    <span class="p">{</span>
        <span class="s1">&#39;variant&#39;</span><span class="p">:</span> <span class="s1">&#39;variant&#39;</span><span class="p">,</span>
        <span class="s1">&#39;version&#39;</span><span class="p">:</span> <span class="s1">&#39;variant&#39;</span><span class="p">,</span>
        <span class="s1">&#39;dnp&#39;</span><span class="p">:</span> <span class="s1">&#39;dnp&#39;</span><span class="p">,</span>
        <span class="s1">&#39;nopop&#39;</span><span class="p">:</span> <span class="s1">&#39;dnp&#39;</span><span class="p">,</span>
        <span class="s1">&#39;description&#39;</span><span class="p">:</span> <span class="s1">&#39;desc&#39;</span><span class="p">,</span>
        <span class="s1">&#39;pdf&#39;</span><span class="p">:</span> <span class="s1">&#39;datasheet&#39;</span><span class="p">,</span>
    <span class="p">}</span>
<span class="p">)</span>


<div class="viewcode-block" id="file_eda_match"><a class="viewcode-back" href="../../../kicost.edas.html#kicost.edas.tools.file_eda_match">[docs]</a><span class="k">def</span> <span class="nf">file_eda_match</span><span class="p">(</span><span class="n">file_name</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;@brief Verify with which EDA the file matches.</span>
<span class="sd">       </span>
<span class="sd">       Return the EDA name with the file matches or `None` if not founded.</span>
<span class="sd">       @param file_name File `str` name.</span>
<span class="sd">       @return Name of the module corresponding to read the file or `None`to not recognized.</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">file_handle</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="n">file_name</span><span class="p">,</span> <span class="s1">&#39;r&#39;</span><span class="p">)</span>
        <span class="n">content</span> <span class="o">=</span> <span class="n">file_handle</span><span class="o">.</span><span class="n">read</span><span class="p">()</span>
    <span class="k">except</span> <span class="ne">UnicodeDecodeError</span><span class="p">:</span> <span class="c1"># It happens with some Windows CSV files on Python 3.</span>
        <span class="n">file_handle</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
        <span class="n">file_handle</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="n">file_name</span><span class="p">,</span> <span class="s1">&#39;r&#39;</span><span class="p">,</span> <span class="n">encoding</span> <span class="o">=</span><span class="s1">&#39;ISO-8859-1&#39;</span><span class="p">)</span>
        <span class="n">content</span> <span class="o">=</span> <span class="n">file_handle</span><span class="o">.</span><span class="n">read</span><span class="p">()</span>
    <span class="n">extension</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">splitext</span><span class="p">(</span><span class="n">file_name</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span>
    <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">defs</span> <span class="ow">in</span> <span class="n">eda_dict</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="c1">#print(name, extension==defs[&#39;file&#39;][&#39;extension&#39;], re.search(defs[&#39;file&#39;][&#39;content&#39;], content, re.IGNORECASE))</span>
        <span class="k">if</span> <span class="n">re</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="n">defs</span><span class="p">[</span><span class="s1">&#39;file&#39;</span><span class="p">][</span><span class="s1">&#39;content&#39;</span><span class="p">],</span> <span class="n">content</span><span class="p">,</span> <span class="n">re</span><span class="o">.</span><span class="n">IGNORECASE</span><span class="p">)</span>\
            <span class="ow">and</span> <span class="n">extension</span><span class="o">==</span><span class="n">defs</span><span class="p">[</span><span class="s1">&#39;file&#39;</span><span class="p">][</span><span class="s1">&#39;extension&#39;</span><span class="p">]:</span>
                <span class="n">file_handle</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
                <span class="k">return</span> <span class="n">name</span>
    <span class="n">file_handle</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
    <span class="k">return</span> <span class="kc">None</span></div>


<span class="k">def</span> <span class="nf">organize_parts</span><span class="p">(</span><span class="n">components</span><span class="p">,</span> <span class="n">fields_merge</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;@brief Organize the parts to better do the scrape in the distributors.</span>
<span class="sd">       </span>
<span class="sd">       Remove the Not Populate Parts (DNP), split the components in unique</span>
<span class="sd">       parts, necessary because of some file formats that present the</span>
<span class="sd">       components already grouped and to finish, group them as group parts</span>
<span class="sd">       with same manufactures codes, company manufactures and distributors</span>
<span class="sd">       codes to not scrape repetitively the same part kind.</span>
<span class="sd">       </span>
<span class="sd">       @param  components Part components in a `list()` of `dict()`, format given by the EDA modules.</span>
<span class="sd">       @return `list()` of `dict()` with the component parts organized (grouped, removed the &quot;not populate&quot;, ...)</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="c1"># Remove the Not Populate Parts.</span>
    <span class="c1">##components = remove_dnp_parts(components, variant) # Do this inside each EDA submodule because of the ISSUE #73.</span>
    <span class="c1"># Split multi-components into individual subparts.</span>
    <span class="n">components</span> <span class="o">=</span> <span class="n">subpartqty_split</span><span class="p">(</span><span class="n">components</span><span class="p">)</span>
    <span class="c1"># Group the components in group in the same characteristics (fields).</span>
    <span class="n">components</span> <span class="o">=</span> <span class="n">group_parts</span><span class="p">(</span><span class="n">components</span><span class="p">,</span> <span class="n">fields_merge</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">components</span>


<span class="c1"># Temporary class for storing part group information.</span>
<span class="k">class</span> <span class="nc">IdenticalComponents</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;@brief Class to group components.&#39;&#39;&#39;</span>
    <span class="k">pass</span>

<div class="viewcode-block" id="group_parts"><a class="viewcode-back" href="../../../kicost.edas.html#kicost.edas.tools.group_parts">[docs]</a><span class="k">def</span> <span class="nf">group_parts</span><span class="p">(</span><span class="n">components</span><span class="p">,</span> <span class="n">fields_merge</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;@brief Group common parts after preprocessing from XML or CSV files.</span>
<span class="sd">       </span>
<span class="sd">       Group common parts looking in the existent files that could be merged</span>
<span class="sd">       by the use of `fields_merge`. First group all designed parts without</span>
<span class="sd">       look the manufacture/distributors codes, after see if any will be</span>
<span class="sd">       propagated (designed part with out information and same values,</span>
<span class="sd">       footprint and so on that other that have manufacture part, receive</span>
<span class="sd">       this code).</span>
<span class="sd">       Count the quantities of each part designed using the &#39;manf#_qty&#39;</span>
<span class="sd">       field, this is important to merge subparts of different parts and</span>
<span class="sd">       parts of different BOMs (in the mode of multifiles).</span>
<span class="sd">       @param components Part components in a `list()` of `dict()`, format given by the EDA modules.</span>
<span class="sd">       @param fields_merge Data fields of the `dict()` variable to be merged and ignored to make the identical components group (before be scraped in the distributors web site).</span>
<span class="sd">       @return `list()` of `dict()`</span>
<span class="sd">    &#39;&#39;&#39;</span>

    <span class="n">logger</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">DEBUG_OVERVIEW</span><span class="p">,</span> <span class="s1">&#39;# Grouping parts...&#39;</span><span class="p">)</span>

    <span class="c1"># All codes to scrape, do not include code field name of distributors</span>
    <span class="c1"># that will not be scraped. This definition is used to create and check</span>
    <span class="c1"># the identical groups or subsplit the seemingly identical parts.</span>
    <span class="n">FIELDS_MANFCAT</span> <span class="o">=</span> <span class="p">([</span><span class="n">d</span> <span class="o">+</span> <span class="s1">&#39;#&#39;</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">distributor_dict</span><span class="p">]</span> <span class="o">+</span> <span class="p">[</span><span class="s1">&#39;manf#&#39;</span><span class="p">])</span>
    <span class="c1"># Calculated all the fields that never have to be used to create the hash keys.</span>
    <span class="c1"># These include all the manufacture company and codes, distributors codes </span>
    <span class="c1"># recognized by the installed modules and, quantity and sub quantity of the part.</span>
    <span class="n">FIELDS_NOT_HASH</span> <span class="o">=</span> <span class="p">([</span><span class="s1">&#39;manf#_qty&#39;</span><span class="p">,</span> <span class="s1">&#39;manf&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="n">FIELDS_MANFCAT</span> <span class="o">+</span> <span class="p">[</span><span class="n">d</span> <span class="o">+</span> <span class="s1">&#39;#_qty&#39;</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">distributor_dict</span><span class="p">])</span>

    <span class="c1"># Check if was asked to merge some not allowed fields (as `manf`, `manf# ...</span>
    <span class="c1"># other ones as `desc` and even `value` and `footprint` may be merged due</span>
    <span class="c1"># the different typed (1uF and 1u) or footprint library names to the same one.</span>
    <span class="n">fields_merge</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span> <span class="p">[</span><span class="n">field_name_translations</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">lower</span><span class="p">(),</span><span class="n">f</span><span class="o">.</span><span class="n">lower</span><span class="p">())</span> <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">fields_merge</span><span class="p">]</span> <span class="p">)</span>
    <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">FIELDS_NOT_HASH</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">fields_merge</span><span class="p">:</span>
             <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Manufacturer/distributor codes and manufacture company &quot;</span><span class="si">{}</span><span class="s1">&quot; can</span><span class="se">\&#39;</span><span class="s1">t be ignored to create the components groups.&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">c</span><span class="p">))</span>
    <span class="n">FIELDS_NOT_HASH</span> <span class="o">=</span> <span class="n">FIELDS_NOT_HASH</span> <span class="o">+</span> <span class="n">fields_merge</span> <span class="c1"># Not use the fields do merge to create the hash.</span>

    <span class="c1"># Now partition the parts into groups of like components.</span>
    <span class="c1"># First, get groups of identical components but ignore any manufacturer&#39;s</span>
    <span class="c1"># part numbers that may be assigned. Just collect those in a list for each group.</span>
    <span class="n">logger</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">DEBUG_OVERVIEW</span><span class="p">,</span> <span class="s1">&#39;Getting groups of identical components...&#39;</span><span class="p">)</span>
    <span class="n">component_groups</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">for</span> <span class="n">ref</span><span class="p">,</span> <span class="n">fields</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="n">components</span><span class="o">.</span><span class="n">items</span><span class="p">()):</span> <span class="c1"># part references and field values.</span>

        <span class="c1"># Take the field keys and values of each part and create a hash.</span>
        <span class="c1"># Use the hash as the key to a dictionary that stores lists of</span>
        <span class="c1"># part references that have identical field values. The important fields</span>
        <span class="c1"># are the reference prefix (&#39;R&#39;, &#39;C&#39;, etc.), value, and footprint.</span>
        <span class="c1"># Don&#39;t use the manufacturer&#39;s part number when calculating the hash!</span>
        <span class="c1"># Also, don&#39;t use any fields with SEPRTR in the label because that indicates</span>
        <span class="c1"># a field used by a specific tool (including KiCost).</span>
        <span class="n">hash_fields</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="n">fields</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">fields</span> <span class="k">if</span> <span class="n">k</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">FIELDS_NOT_HASH</span> <span class="ow">and</span> <span class="n">SEPRTR</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">k</span><span class="p">}</span>
        <span class="n">h</span> <span class="o">=</span> <span class="nb">hash</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="nb">sorted</span><span class="p">(</span><span class="n">hash_fields</span><span class="o">.</span><span class="n">items</span><span class="p">())))</span>

        <span class="c1"># Now add the hashed component to the group with the matching hash</span>
        <span class="c1"># or create a new group if the hash hasn&#39;t been seen before.</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="c1"># Add next ref for identical part to the list.</span>
            <span class="n">component_groups</span><span class="p">[</span><span class="n">h</span><span class="p">]</span><span class="o">.</span><span class="n">refs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ref</span><span class="p">)</span>
            <span class="c1"># Also add any manufacturer&#39;s part number (or None) and each distributor</span>
            <span class="c1"># stock catologue code to the group&#39;s list.</span>
            <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">FIELDS_MANFCAT</span><span class="p">:</span>
                <span class="n">component_groups</span><span class="p">[</span><span class="n">h</span><span class="p">]</span><span class="o">.</span><span class="n">manfcat_codes</span><span class="p">[</span><span class="n">f</span><span class="p">]</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">fields</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">f</span><span class="p">))</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
            <span class="c1"># This happens if it is the first part in a group, so the group</span>
            <span class="c1"># doesn&#39;t exist yet.</span>
            <span class="n">component_groups</span><span class="p">[</span><span class="n">h</span><span class="p">]</span> <span class="o">=</span> <span class="n">IdenticalComponents</span><span class="p">()</span>  <span class="c1"># Add empty structure.</span>
            <span class="n">component_groups</span><span class="p">[</span><span class="n">h</span><span class="p">]</span><span class="o">.</span><span class="n">refs</span> <span class="o">=</span> <span class="p">[</span><span class="n">ref</span><span class="p">]</span>  <span class="c1"># Init list of refs with first ref.</span>
            <span class="c1"># Now add the manf. part code (or None) and each distributor stock</span>
            <span class="c1"># catologue code for this part to the group set.</span>
            <span class="n">component_groups</span><span class="p">[</span><span class="n">h</span><span class="p">]</span><span class="o">.</span><span class="n">manfcat_codes</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">FIELDS_MANFCAT</span><span class="p">:</span>
                <span class="n">component_groups</span><span class="p">[</span><span class="n">h</span><span class="p">]</span><span class="o">.</span><span class="n">manfcat_codes</span><span class="p">[</span><span class="n">f</span><span class="p">]</span> <span class="o">=</span> <span class="nb">set</span><span class="p">([</span><span class="n">fields</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">f</span><span class="p">)])</span>
    <span class="c1">#print(&#39;\n\n\n1++++++++++++++&#39;,len(component_groups))</span>
    <span class="c1">#for g,grp in list(component_groups.items()):</span>
    <span class="c1">#    print(&#39;\n&#39;, grp.refs)</span>
    <span class="c1">#    for r in grp.refs:</span>
    <span class="c1">#        print(r, components[r])</span>


    <span class="c1"># Now we have groups of seemingly identical parts. But some of the parts</span>
    <span class="c1"># within a group may have different manufacturer&#39;s part numbers, and these</span>
    <span class="c1"># groups may need to be split into smaller groups of parts all having the</span>
    <span class="c1"># same manufacturer&#39;s number. Here are the cases that need to be handled:</span>
    <span class="c1">#   One manf# number (and one cat# for each distributor):</span>
    <span class="c1">#       All parts have the same manf#. Don&#39;t split this group.</span>
    <span class="c1">#   Two manf# numbers (or cat# distributor code), but one is `None`:</span>
    <span class="c1">#       Some of the parts have no manf# or distributor# but are otherwise</span>
    <span class="c1">#       identical to the other parts in the group. Don&#39;t split this group.</span>
    <span class="c1">#       Instead, propagate the non-None manf# to all the parts.</span>
    <span class="c1">#   Two manf# (or two cat# distributor code), neither is `None`:</span>
    <span class="c1">#       All parts have non-`None` manf# and distributor# numbers. Split</span>
    <span class="c1">#       the group into two smaller groups of parts all having the same</span>
    <span class="c1">#       manf# and distributor#.</span>
    <span class="c1">#   Three or more manf# (or distributor#):</span>
    <span class="c1">#       Split this group into smaller groups, each one with parts having</span>
    <span class="c1">#       the same manf# and distributor#, even if it&#39;s `None`. It&#39;s</span>
    <span class="c1">#       impossible to determine which manf# the `None` parts should be</span>
    <span class="c1">#       assigned to, so leave their manf# as `None`.</span>
    <span class="n">logger</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">DEBUG_OVERVIEW</span><span class="p">,</span> <span class="s1">&#39;Checking the seemingly identical parts group...&#39;</span><span class="p">)</span>
    <span class="n">new_component_groups</span> <span class="o">=</span> <span class="p">[]</span> <span class="c1"># Copy new component groups into this.</span>
    <span class="k">for</span> <span class="n">g</span><span class="p">,</span> <span class="n">grp</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="n">component_groups</span><span class="o">.</span><span class="n">items</span><span class="p">()):</span>
        <span class="n">num_manfcat_codes</span> <span class="o">=</span> <span class="p">{</span><span class="n">f</span><span class="p">:</span><span class="nb">len</span><span class="p">(</span><span class="n">grp</span><span class="o">.</span><span class="n">manfcat_codes</span><span class="p">[</span><span class="n">f</span><span class="p">])</span> <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">FIELDS_MANFCAT</span><span class="p">}</span>
        <span class="k">if</span> <span class="nb">all</span><span class="p">([</span><span class="n">num_manfcat_codes</span><span class="p">[</span><span class="n">f</span><span class="p">]</span><span class="o">==</span><span class="mi">1</span> <span class="ow">or</span> <span class="p">(</span><span class="n">num_manfcat_codes</span><span class="p">[</span><span class="n">f</span><span class="p">]</span><span class="o">==</span><span class="mi">2</span> <span class="ow">and</span> <span class="kc">None</span> <span class="ow">in</span> <span class="n">grp</span><span class="o">.</span><span class="n">manfcat_codes</span><span class="p">[</span><span class="n">f</span><span class="p">])</span> <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">FIELDS_MANFCAT</span><span class="p">]):</span>
            <span class="n">new_component_groups</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">grp</span><span class="p">)</span>
            <span class="k">continue</span>  <span class="c1"># CASE ONE and TWO:</span>
                      <span class="c1"># Single manf# and distributor catalogue. Or a seemingly</span>
                      <span class="c1"># identical group with just one valid manf# or cat# code,</span>
                      <span class="c1"># the other one is `None`.Don&#39;t split this group. `None`</span>
                      <span class="c1"># will be replaced with the propagated manufacture /</span>
                      <span class="c1"># distributor catalogue code.</span>
        <span class="k">elif</span> <span class="nb">all</span><span class="p">([(</span><span class="n">num_manfcat_codes</span><span class="p">[</span><span class="n">f</span><span class="p">]</span><span class="o">==</span><span class="mi">1</span> <span class="ow">and</span> <span class="n">grp</span><span class="o">.</span><span class="n">manfcat_codes</span><span class="p">[</span><span class="n">f</span><span class="p">]</span><span class="o">==</span><span class="kc">None</span><span class="p">)</span> <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">FIELDS_MANFCAT</span><span class="p">]):</span>
            <span class="n">new_component_groups</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">grp</span><span class="p">)</span>
            <span class="k">continue</span>  <span class="c1"># CASE THREE:</span>
                      <span class="c1"># One manf# or cat# that is `None`. Don&#39;t split this</span>
                      <span class="c1"># group. These parts are not intended to be purchased.</span>
        <span class="c1"># CASE FOUR:</span>
        <span class="c1"># Otherwise, split the group into subgroups, each with the</span>
        <span class="c1"># same manf# and distributors catalogue codes (for that one</span>
        <span class="c1"># that will be scraped, the other ones are not considered).</span>
        <span class="k">for</span> <span class="n">i_manfcat</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">max</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="n">grp</span><span class="o">.</span><span class="n">manfcat_codes</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">f</span><span class="p">))</span> <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">FIELDS_MANFCAT</span><span class="p">])):</span>
            <span class="n">manfcat_num</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">FIELDS_MANFCAT</span><span class="p">:</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">manfcat_num</span><span class="p">[</span><span class="n">f</span><span class="p">]</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">grp</span><span class="o">.</span><span class="n">manfcat_codes</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">f</span><span class="p">))[</span><span class="n">i_manfcat</span><span class="p">]</span>
                <span class="k">except</span> <span class="ne">IndexError</span><span class="p">:</span>
                    <span class="c1"># If not have more code in the set list, is because just</span>
                    <span class="c1"># exist one. So use this as general.</span>
                    <span class="n">manfcat_num</span><span class="p">[</span><span class="n">f</span><span class="p">]</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">grp</span><span class="o">.</span><span class="n">manfcat_codes</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">f</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">sub_group</span> <span class="o">=</span> <span class="n">IdenticalComponents</span><span class="p">()</span>
            <span class="n">sub_group</span><span class="o">.</span><span class="n">manfcat_codes</span> <span class="o">=</span> <span class="p">[</span><span class="n">manfcat_num</span><span class="p">]</span>
            <span class="n">sub_group</span><span class="o">.</span><span class="n">refs</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">ref</span> <span class="ow">in</span> <span class="n">grp</span><span class="o">.</span><span class="n">refs</span><span class="p">:</span>
                <span class="c1"># Use get() which returns `None` if the component has no</span>
                <span class="c1"># manf# or distributor# field. That will match if the</span>
                <span class="c1"># group manf_num is also None. So append the par to the group.</span>
                <span class="k">if</span> <span class="nb">all</span><span class="p">([</span><span class="n">components</span><span class="p">[</span><span class="n">ref</span><span class="p">]</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">f</span><span class="p">)</span><span class="o">==</span><span class="n">manfcat_num</span><span class="p">[</span><span class="n">f</span><span class="p">]</span> <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">FIELDS_MANFCAT</span><span class="p">]):</span>
                    <span class="n">sub_group</span><span class="o">.</span><span class="n">refs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ref</span><span class="p">)</span>
            <span class="n">new_component_groups</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">sub_group</span><span class="p">)</span> <span class="c1"># Append one part of the split group.</span>
    <span class="c1">#print(&#39;\n\n\n2++++++++++++++&#39;,len(new_component_groups))</span>
    <span class="c1">#for grp in new_component_groups:</span>
    <span class="c1">#    print(&#39;\n&#39;, grp.refs)</span>
    <span class="c1">#    for r in grp.refs:</span>
    <span class="c1">#        print(r, components[r])</span>

    <span class="c1"># If the identical components grouped have difference in the `fields_merge`</span>
    <span class="c1"># so replace this field with a string composed line-by-line with the</span>
    <span class="c1"># occurrences (definition `SGROUP_SEPRTR`) preceded with the refs</span>
    <span class="c1"># collapsed plus `SEPRTR`. Implementation of the ISSUE #102.</span>
    <span class="n">logger</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">DEBUG_OVERVIEW</span><span class="p">,</span> <span class="s1">&#39;Merging field asked in the identical components groups...&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">fields_merge</span><span class="p">:</span>
        <span class="n">fields_merge</span> <span class="o">=</span> <span class="p">[</span><span class="n">field_name_translations</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">lower</span><span class="p">(),</span> <span class="n">f</span><span class="o">.</span><span class="n">lower</span><span class="p">())</span> <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">fields_merge</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">grp</span> <span class="ow">in</span> <span class="n">new_component_groups</span><span class="p">:</span>
            <span class="n">components_grp</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
            <span class="n">components_grp</span> <span class="o">=</span> <span class="p">{</span><span class="n">i</span><span class="p">:</span><span class="n">components</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">grp</span><span class="o">.</span><span class="n">refs</span><span class="p">}</span>
            <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">fields_merge</span><span class="p">:</span>
                <span class="n">values_field</span> <span class="o">=</span> <span class="p">[</span><span class="n">v</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span><span class="n">v</span> <span class="ow">in</span> <span class="n">components_grp</span><span class="o">.</span><span class="n">items</span><span class="p">()]</span>
                <span class="n">ocurrences</span> <span class="o">=</span> <span class="p">{</span><span class="n">v_g</span><span class="p">:[</span> <span class="n">r</span> <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">grp</span><span class="o">.</span><span class="n">refs</span> <span class="k">if</span> <span class="n">components</span><span class="p">[</span><span class="n">r</span><span class="p">]</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">f</span><span class="p">,</span><span class="s1">&#39;&#39;</span><span class="p">)</span> <span class="o">==</span> <span class="n">v_g</span><span class="p">]</span> <span class="k">for</span> <span class="n">v_g</span> <span class="ow">in</span> <span class="nb">set</span><span class="p">(</span><span class="n">values_field</span><span class="p">)}</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">ocurrences</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">1</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">f</span><span class="o">==</span><span class="s1">&#39;desc&#39;</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">ocurrences</span><span class="p">)</span><span class="o">==</span><span class="mi">2</span> <span class="ow">and</span> <span class="s1">&#39;&#39;</span> <span class="ow">in</span> <span class="n">ocurrences</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                        <span class="n">value</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">ocurrences</span><span class="o">.</span><span class="n">keys</span><span class="p">()))</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">value</span> <span class="o">=</span> <span class="n">SGROUP_SEPRTR</span><span class="o">.</span><span class="n">join</span><span class="p">(</span> <span class="p">[</span><span class="s1">&#39;,&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span> <span class="n">order_refs</span><span class="p">(</span><span class="n">r</span><span class="p">)</span> <span class="p">)</span> <span class="o">+</span> <span class="n">SEPRTR</span> <span class="o">+</span> <span class="s1">&#39; &#39;</span> <span class="o">+</span> <span class="n">t</span> <span class="k">for</span> <span class="n">t</span><span class="p">,</span><span class="n">r</span> <span class="ow">in</span> <span class="n">ocurrences</span><span class="o">.</span><span class="n">items</span><span class="p">()]</span> <span class="p">)</span>
                    <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">grp</span><span class="o">.</span><span class="n">refs</span><span class="p">:</span>
                        <span class="n">components</span><span class="p">[</span><span class="n">r</span><span class="p">][</span><span class="n">f</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>
    <span class="c1">#print(&#39;\n\n\n3++++++++++++++&#39;,len(new_component_groups))</span>
    <span class="c1">#for grp in new_component_groups:</span>
    <span class="c1">#    print(grp.refs)</span>
    <span class="c1">#    for r in grp.refs:</span>
    <span class="c1">#        print(r, components[r])</span>

    <span class="c1"># Now get the values of all fields within the members of a group.</span>
    <span class="c1"># These will become the field values for ALL members of that group.</span>
    <span class="n">logger</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">DEBUG_OVERVIEW</span><span class="p">,</span> <span class="s1">&#39;Propagating field values to identical components...&#39;</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">grp</span> <span class="ow">in</span> <span class="n">new_component_groups</span><span class="p">:</span>
        <span class="n">grp_fields</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">qty</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">ref</span> <span class="ow">in</span> <span class="n">grp</span><span class="o">.</span><span class="n">refs</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="n">components</span><span class="p">[</span><span class="n">ref</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">()):</span>
                <span class="k">if</span> <span class="n">key</span> <span class="o">==</span> <span class="s1">&#39;manf#_qty&#39;</span><span class="p">:</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">val</span><span class="p">)):</span>
                            <span class="n">grp_fields</span><span class="p">[</span><span class="s1">&#39;manf#_qty&#39;</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">+=</span> <span class="s1">&#39;+&#39;</span> <span class="o">+</span> <span class="n">val</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="c1"># DUMMY way and need improvement to really do arithmetic and not string cat. #TODO</span>
                            <span class="n">val</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">grp_fields</span><span class="p">[</span><span class="s1">&#39;manf#_qty&#39;</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="c1"># Make the first values take also equal.</span>
                    <span class="k">except</span><span class="p">:</span>
                        <span class="n">grp_fields</span><span class="p">[</span><span class="s1">&#39;manf#_qty&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">val</span>
                    <span class="k">continue</span>
                <span class="k">if</span> <span class="n">val</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span> <span class="c1"># Field with no value...</span>
                    <span class="k">continue</span> <span class="c1"># so ignore it.</span>
                <span class="k">if</span> <span class="n">grp_fields</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">key</span><span class="p">):</span> <span class="c1"># This field has been seen before.</span>
                    <span class="k">if</span> <span class="n">grp_fields</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">!=</span> <span class="n">val</span><span class="p">:</span> <span class="c1"># Flag if new field value not the same as old.</span>
                        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Field value mismatch: ref=</span><span class="si">{}</span><span class="s1"> field=</span><span class="si">{}</span><span class="s1"> value=</span><span class="se">\&#39;</span><span class="si">{}</span><span class="se">\&#39;</span><span class="s1">, global=</span><span class="se">\&#39;</span><span class="si">{}</span><span class="se">\&#39;</span><span class="s1"> at group=</span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">ref</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">grp_fields</span><span class="p">[</span><span class="n">key</span><span class="p">],</span> <span class="n">grp</span><span class="o">.</span><span class="n">refs</span><span class="p">))</span>
                <span class="k">else</span><span class="p">:</span> <span class="c1"># First time this field has been seen in the group, so store it.</span>
                    <span class="n">grp_fields</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">val</span>
        <span class="n">grp</span><span class="o">.</span><span class="n">fields</span> <span class="o">=</span> <span class="n">grp_fields</span>

    <span class="c1"># Now return the list of identical part groups.</span>
    <span class="c1">#print(&#39;\n\n\n------------&#39;)</span>
    <span class="c1">#for grp in new_component_groups:</span>
    <span class="c1">#    print(grp.refs)</span>
    <span class="c1">#    for r in grp.refs:</span>
    <span class="c1">#        print(r, components[r])</span>
    <span class="k">return</span> <span class="n">new_component_groups</span></div>


<span class="k">def</span> <span class="nf">remove_dnp_parts</span><span class="p">(</span><span class="n">components</span><span class="p">,</span> <span class="n">variant</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;@brief Remove the DNP parts or not assigned to the current variant.</span>
<span class="sd">       </span>
<span class="sd">       Remove components that are assigned to a variant that is not the current variant,</span>
<span class="sd">       or which are &quot;do not populate&quot; (DNP). (Any component that does not have a variant</span>
<span class="sd">       is assigned the current variant so it will not be removed unless it is also DNP.)</span>
<span class="sd">       </span>
<span class="sd">       @param components Part components in a `list()` of `dict()`, format given by the EDA modules.</span>
<span class="sd">       @return `list()` of `dict()`.</span>
<span class="sd">    &#39;&#39;&#39;</span>

    <span class="n">logger</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">DEBUG_OVERVIEW</span><span class="p">,</span> <span class="s1">&#39;# Removing do not populate parts...&#39;</span><span class="p">)</span>

    <span class="n">accepted_components</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">for</span> <span class="n">ref</span><span class="p">,</span> <span class="n">fields</span> <span class="ow">in</span> <span class="n">components</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="c1"># Remove DNPs.</span>
        <span class="n">dnp</span> <span class="o">=</span> <span class="n">fields</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;local:dnp&#39;</span><span class="p">,</span> <span class="n">fields</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;dnp&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">dnp</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">dnp</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
            <span class="k">pass</span>  <span class="c1"># The field value must have been a string.</span>
        <span class="k">if</span> <span class="n">dnp</span><span class="p">:</span>
            <span class="k">continue</span>

        <span class="c1"># Get part variant. Prioritize local variants over global ones.</span>
        <span class="n">variants</span> <span class="o">=</span> <span class="n">fields</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;local:variant&#39;</span><span class="p">,</span> <span class="n">fields</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;variant&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">))</span>

        <span class="c1"># Remove parts that are not assigned to the current variant.</span>
        <span class="c1"># If a part is not assigned to any variant, then it is never removed.</span>
        <span class="k">if</span> <span class="n">variants</span><span class="p">:</span>
            <span class="c1"># A part can be assigned to multiple variants. The part will not</span>
            <span class="c1"># be removed if any of its variants match the current variant.</span>
            <span class="c1"># Split the variants apart and abort the loop if any of them match.</span>
            <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">re</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;[,;/ ]&#39;</span><span class="p">,</span> <span class="n">variants</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">re</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">variant</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">flags</span><span class="o">=</span><span class="n">re</span><span class="o">.</span><span class="n">IGNORECASE</span><span class="p">):</span>
                    <span class="k">break</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># None of the variants matched, so skip/remove this part.</span>
                <span class="k">continue</span>

        <span class="c1"># The part was not removed, so add it to the list of accepted components.</span>
        <span class="n">accepted_components</span><span class="p">[</span><span class="n">ref</span><span class="p">]</span> <span class="o">=</span> <span class="n">fields</span>
    
    <span class="k">return</span> <span class="n">accepted_components</span>


<div class="viewcode-block" id="groups_sort"><a class="viewcode-back" href="../../../kicost.edas.html#kicost.edas.tools.groups_sort">[docs]</a><span class="k">def</span> <span class="nf">groups_sort</span><span class="p">(</span><span class="n">new_component_groups</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;@brief Order the groups in a alphabetical way.</span>
<span class="sd">       </span>
<span class="sd">       Put the components groups in the spreadsheet rows in a specific order</span>
<span class="sd">       using the reference string of the components. The order is defined</span>
<span class="sd">       by BOM_ORDER.</span>
<span class="sd">       @param components Part components in a `list()` of `dict()`, format given by the EDA modules.</span>
<span class="sd">       @return Same as input.</span>
<span class="sd">    &#39;&#39;&#39;</span>

    <span class="n">logger</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">DEBUG_OVERVIEW</span><span class="p">,</span> <span class="s1">&#39;Sorting the groups for better visualization...&#39;</span><span class="p">)</span>

    <span class="n">ref_identifiers</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;(?&lt;![\W\*\/])\s*,\s*|\s*,\s*(?![\W\*\/])&#39;</span><span class="p">,</span>
                <span class="n">BOM_ORDER</span><span class="p">,</span> <span class="n">flags</span><span class="o">=</span><span class="n">re</span><span class="o">.</span><span class="n">IGNORECASE</span><span class="p">)</span>
    <span class="n">component_groups_order_old</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">new_component_groups</span><span class="p">))</span> <span class="p">)</span>
    <span class="n">component_groups_order_new</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
    <span class="n">component_groups_refs</span> <span class="o">=</span> <span class="p">[</span><span class="n">new_component_groups</span><span class="p">[</span><span class="n">g</span><span class="p">]</span><span class="o">.</span><span class="n">fields</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;reference&#39;</span><span class="p">)</span> <span class="k">for</span> <span class="n">g</span> <span class="ow">in</span> <span class="n">component_groups_order_old</span><span class="p">]</span>
    <span class="n">logger</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">DEBUG_OBSESSIVE</span><span class="p">,</span> <span class="s1">&#39;All ref identifier: </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">ref_identifiers</span><span class="p">)</span> <span class="p">)</span>
    <span class="n">logger</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">DEBUG_OBSESSIVE</span><span class="p">,</span> <span class="s1">&#39;</span><span class="si">{}</span><span class="s1"> groups of components.&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">component_groups_order_old</span><span class="p">))</span> <span class="p">)</span>
    <span class="n">logger</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">DEBUG_OBSESSIVE</span><span class="p">,</span> <span class="s1">&#39;Identifiers founded </span><span class="si">{}</span><span class="s1">.&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">component_groups_refs</span><span class="p">)</span> <span class="p">)</span>
    <span class="k">for</span> <span class="n">ref_identifier</span> <span class="ow">in</span> <span class="n">ref_identifiers</span><span class="p">:</span>
        <span class="n">component_groups_ref_match</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">component_groups_refs</span><span class="p">))</span> <span class="k">if</span> <span class="n">ref_identifier</span><span class="o">==</span><span class="n">component_groups_refs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">lower</span><span class="p">()]</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">DEBUG_OBSESSIVE</span><span class="p">,</span> <span class="s1">&#39;Identifier: </span><span class="si">{}</span><span class="s1"> in </span><span class="si">{}</span><span class="s1">.&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">ref_identifier</span><span class="p">,</span> <span class="n">component_groups_ref_match</span><span class="p">)</span> <span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">component_groups_ref_match</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">:</span>
            <span class="c1"># If found more than one group with the reference, use the &#39;manf#&#39;</span>
            <span class="c1"># as second order criteria.</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">component_groups_ref_match</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">1</span><span class="p">:</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">component_groups_ref_match</span><span class="p">:</span>
                        <span class="n">component_groups_order_old</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">item</span><span class="p">)</span>
                <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
                    <span class="k">pass</span>
                <span class="c1"># Examine &#39;manf#&#39; and refs to get the order.</span>
                <span class="c1"># Order by refs that have &#39;manf#&#39; codes, that ones that don&#39;t have stay at the end of the group.</span>
                <span class="n">group_manf_list</span> <span class="o">=</span> <span class="p">[</span><span class="n">new_component_groups</span><span class="p">[</span><span class="n">h</span><span class="p">]</span><span class="o">.</span><span class="n">fields</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;manf#&#39;</span><span class="p">)</span> <span class="k">for</span> <span class="n">h</span> <span class="ow">in</span> <span class="n">component_groups_ref_match</span><span class="p">]</span>
                <span class="n">group_refs_list</span> <span class="o">=</span> <span class="p">[</span><span class="n">new_component_groups</span><span class="p">[</span><span class="n">h</span><span class="p">]</span><span class="o">.</span><span class="n">refs</span> <span class="k">for</span> <span class="n">h</span> <span class="ow">in</span> <span class="n">component_groups_ref_match</span><span class="p">]</span>
                <span class="n">sorted_groups</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">group_refs_list</span><span class="p">)),</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">k</span><span class="p">:(</span><span class="n">group_manf_list</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">,</span>  <span class="n">group_refs_list</span><span class="p">[</span><span class="n">k</span><span class="p">]))</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">DEBUG_OBSESSIVE</span><span class="p">,</span> <span class="s1">&#39;</span><span class="si">{}</span><span class="s1"> &gt; order: </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span> <span class="n">group_manf_list</span><span class="p">,</span> <span class="n">sorted_groups</span><span class="p">)</span> <span class="p">)</span>
                <span class="n">component_groups_ref_match</span> <span class="o">=</span> <span class="p">[</span><span class="n">component_groups_ref_match</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">sorted_groups</span><span class="p">]</span>
                <span class="n">component_groups_order_new</span> <span class="o">+=</span> <span class="n">component_groups_ref_match</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">component_groups_order_old</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">component_groups_ref_match</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
                    <span class="k">pass</span>
                <span class="n">component_groups_order_new</span> <span class="o">+=</span> <span class="n">component_groups_ref_match</span>
    <span class="c1"># The new order is the found refs first and at the last the not referenced in BOM_ORDER.</span>
    <span class="n">component_groups_order_new</span> <span class="o">+=</span> <span class="n">component_groups_order_old</span> <span class="c1"># Add the missing references groups.</span>
    <span class="n">new_component_groups</span> <span class="o">=</span> <span class="p">[</span><span class="n">new_component_groups</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">component_groups_order_new</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">new_component_groups</span></div>


<div class="viewcode-block" id="subpartqty_split"><a class="viewcode-back" href="../../../kicost.edas.html#kicost.edas.tools.subpartqty_split">[docs]</a><span class="k">def</span> <span class="nf">subpartqty_split</span><span class="p">(</span><span class="n">components</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;@brief Split the components with subparts in different components.</span>
<span class="sd">       </span>
<span class="sd">       Take each part and the all manufacture/distributors combination</span>
<span class="sd">       possibility to split in subpart the components part that have</span>
<span class="sd">       more than one manufacture/distributors code.</span>
<span class="sd">       For each designator...</span>
<span class="sd">       For designator with a &quot;single subpart&quot; check with the quantity</span>
<span class="sd">       is more than one.</span>
<span class="sd">       </span>
<span class="sd">       @param components Part components in a `list()` of `dict()`, format given by the EDA modules.</span>
<span class="sd">       @return Same as the input.</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">logger</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">DEBUG_OVERVIEW</span><span class="p">,</span> <span class="s1">&#39;Splitting subparts in the manufacture / distributors codes...&#39;</span><span class="p">)</span>

    <span class="n">FIELDS_MANF</span> <span class="o">=</span> <span class="p">[</span><span class="n">d</span><span class="o">+</span><span class="s1">&#39;#&#39;</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">distributor_dict</span><span class="p">]</span>
    <span class="n">FIELDS_MANF</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;manf#&#39;</span><span class="p">)</span>

    <span class="n">split_components</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">for</span> <span class="n">part_ref</span><span class="p">,</span> <span class="n">part</span> <span class="ow">in</span> <span class="n">components</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="c1"># Divide the subparts in different parts keeping the other fields</span>
            <span class="c1"># (reference, description, ...).</span>
            <span class="c1"># First search for the used fields to manufacture/distributor numbers</span>
            <span class="c1"># and how many subparts are in them. Use the loop also to extract the</span>
            <span class="c1"># manufacture/distributor codes in list. Use the maximum of them.</span>
            <span class="n">founded_fields</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">subparts_qty</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">subparts_manf_code</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">field_code</span> <span class="ow">in</span> <span class="n">FIELDS_MANF</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">field_code</span> <span class="ow">in</span> <span class="n">part</span><span class="p">:</span>
                    <span class="n">subparts_qty_field</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span> <span class="n">subpart_list</span><span class="p">(</span><span class="n">part</span><span class="p">[</span><span class="n">field_code</span><span class="p">])</span> <span class="p">)</span>
                    <span class="n">subparts_qty</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">subparts_qty</span><span class="p">,</span> <span class="n">subparts_qty_field</span><span class="p">)</span> <span class="c1"># Quantity of sub parts.</span>
                    <span class="c1"># Print a warning and an user tip in the case of different subpart quantities</span>
                    <span class="c1"># associated in different `manf#`/distributors# of the same component.</span>
                    <span class="k">if</span> <span class="n">subparts_qty_field</span><span class="o">!=</span><span class="n">subparts_qty</span><span class="p">:</span>
                        <span class="n">problem_manf_code</span> <span class="o">=</span> <span class="p">(</span><span class="n">field_code</span> <span class="k">if</span> <span class="n">subparts_qty</span><span class="o">&gt;</span><span class="n">subparts_qty_field</span> <span class="k">else</span> <span class="n">field_code_last</span><span class="p">)</span>
                        <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s1">&#39;Found a different subpart quantity between the code fields </span><span class="si">{c}</span><span class="s1"> and </span><span class="si">{lc}</span><span class="s1">.</span><span class="se">\n\t</span><span class="s1">You should consider use </span><span class="se">\&quot;</span><span class="si">{pc}</span><span class="s1">=</span><span class="si">{m}</span><span class="se">\&quot;</span><span class="s1"> on </span><span class="si">{r}</span><span class="s1"> to disambiguate that.&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                                        <span class="n">c</span><span class="o">=</span><span class="n">field_code_last</span><span class="p">,</span> <span class="n">lc</span><span class="o">=</span><span class="n">field_code</span><span class="p">,</span> <span class="n">r</span><span class="o">=</span><span class="n">part_ref</span><span class="p">,</span>
                                        <span class="n">pc</span><span class="o">=</span><span class="n">problem_manf_code</span><span class="p">,</span>
                                        <span class="n">m</span><span class="o">=</span><span class="s1">&#39;;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">subpart_list</span><span class="p">(</span><span class="n">part</span><span class="p">[</span><span class="n">problem_manf_code</span><span class="p">])</span><span class="o">+</span><span class="p">[</span><span class="s1">&#39;&#39;</span><span class="p">]</span><span class="o">*</span><span class="nb">abs</span><span class="p">(</span><span class="n">subparts_qty</span> <span class="o">-</span> <span class="n">subparts_qty_field</span><span class="p">))</span>
                                  <span class="p">))</span>
                    <span class="n">field_code_last</span> <span class="o">=</span> <span class="n">field_code</span>
                    
                    <span class="n">founded_fields</span> <span class="o">+=</span> <span class="p">[</span><span class="n">field_code</span><span class="p">]</span>
                    <span class="n">subparts_manf_code</span><span class="p">[</span><span class="n">field_code</span><span class="p">]</span> <span class="o">=</span> <span class="n">subpart_list</span><span class="p">(</span><span class="n">part</span><span class="p">[</span><span class="n">field_code</span><span class="p">])</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">founded_fields</span><span class="p">:</span>
                <span class="n">split_components</span><span class="p">[</span><span class="n">part_ref</span><span class="p">]</span> <span class="o">=</span> <span class="n">part</span>
                <span class="k">continue</span> <span class="c1"># If not manf/distributor code pass to next.</span>
            <span class="c1"># Divide the `manf` manufacture name.</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">subparts_manf</span> <span class="o">=</span> <span class="n">subpart_list</span><span class="p">(</span><span class="n">part</span><span class="p">[</span><span class="s1">&#39;manf&#39;</span><span class="p">])</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">subparts_manf</span><span class="p">)</span><span class="o">!=</span><span class="n">subparts_qty</span><span class="p">:</span>
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">subparts_manf</span><span class="p">)</span><span class="o">==</span><span class="mi">1</span><span class="p">:</span>
                        <span class="c1"># If just one `manf`assumes that is for all.</span>
                        <span class="n">subparts_manf</span> <span class="o">=</span> <span class="p">[</span><span class="n">subparts_manf</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span><span class="o">*</span><span class="n">subparts_qty</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="c1"># Exception `manf` and `manf#` length doesn&#39;t match, fill with &#39;&#39; at the end.</span>
                        <span class="n">subparts_manf</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="s1">&#39;&#39;</span><span class="p">]</span><span class="o">*</span><span class="p">(</span><span class="n">subparts_qty</span><span class="o">-</span><span class="nb">len</span><span class="p">(</span><span class="n">subparts_manf</span><span class="p">)))</span>
            <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                <span class="n">subparts_manf</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;&#39;</span><span class="p">]</span><span class="o">*</span><span class="n">subparts_qty</span>
                <span class="k">pass</span>

            <span class="n">logger</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">DEBUG_DETAILED</span><span class="p">,</span> <span class="s1">&#39;</span><span class="si">{}</span><span class="s1"> &gt;&gt; </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">part_ref</span><span class="p">,</span> <span class="n">founded_fields</span><span class="p">)</span> <span class="p">)</span>

            <span class="c1"># Second, if more than one subpart, split the sub parts as</span>
            <span class="c1"># new components with the same description, footprint, and</span>
            <span class="c1"># so on... Get the subpart.</span>
            <span class="k">if</span> <span class="n">subparts_qty</span><span class="o">&gt;</span><span class="mi">1</span><span class="p">:</span>
                <span class="c1"># Remove the actual part from the list.</span>
                <span class="n">part_actual</span> <span class="o">=</span> <span class="n">part</span>
                <span class="n">part_actual_value</span> <span class="o">=</span> <span class="n">part_actual</span><span class="p">[</span><span class="s1">&#39;value&#39;</span><span class="p">]</span>
                <span class="n">subpart_part</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span>
                <span class="n">subpart_qty</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span>
                <span class="c1"># Add the split subparts.</span>
                <span class="k">for</span> <span class="n">subparts_index</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">subparts_qty</span><span class="p">):</span>
                    <span class="c1"># Create a sub component based on the main component with</span>
                    <span class="c1"># the subparts. Modify the designator and the part. Create</span>
                    <span class="c1"># a sub quantity field.</span>
                    <span class="n">subpart_actual</span> <span class="o">=</span> <span class="n">part_actual</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
                    <span class="n">subpart_qty_prior</span> <span class="o">=</span> <span class="p">[]</span> <span class="c1"># Use this last cycle variable to warning the user about</span>
                    <span class="n">p_manf_code_prior</span> <span class="o">=</span> <span class="p">[]</span> <span class="c1"># different quantities in the fields `manf#` and `cat#`.</span>
                    <span class="n">field_manf_dist_code_prior</span> <span class="o">=</span> <span class="p">[]</span>
                    <span class="k">for</span> <span class="n">field_manf_dist_code</span> <span class="ow">in</span> <span class="n">founded_fields</span><span class="p">:</span>
                        <span class="c1"># For each manufacture/distributor code take the same order of</span>
                        <span class="c1"># the code list and split in each subpart. When not founded one</span>
                        <span class="c1"># part, do not add.</span>
                        <span class="c1"># e.g. U1:{&#39;manf#&#39;:&#39;PARTG1;PARTG2;PARTG3&#39;, &#39;mouser#&#39;&#39;PARTM1;PARTM2&#39;}</span>
                        <span class="c1"># result:</span>
                        <span class="c1"># U1.1:{&#39;manf#&#39;:&#39;PARTG1&#39;, &#39;mouser#&#39;:&#39;PARTM1&#39;}</span>
                        <span class="c1"># U1.2:{&#39;manf#&#39;:&#39;PARTG2&#39;, &#39;mouser#&#39;:&#39;PARTM2&#39;}</span>
                        <span class="c1"># U1.3:{&#39;manf#&#39;:&#39;PARTG3&#39;}</span>
                        <span class="k">try</span><span class="p">:</span>
                            <span class="n">p_manf_code</span> <span class="o">=</span> <span class="n">subparts_manf_code</span><span class="p">[</span><span class="n">field_manf_dist_code</span><span class="p">][</span><span class="n">subparts_index</span><span class="p">]</span>
                            <span class="n">subpart_actual</span><span class="p">[</span><span class="s1">&#39;value&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="si">{v}</span><span class="s1"> - p</span><span class="si">{idx}</span><span class="s1">/</span><span class="si">{total}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                                            <span class="n">v</span><span class="o">=</span><span class="n">part_actual_value</span><span class="p">,</span>
                                            <span class="n">idx</span><span class="o">=</span><span class="n">subparts_index</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span>
                                            <span class="n">total</span><span class="o">=</span><span class="n">subparts_qty</span><span class="p">)</span>
                            <span class="n">subpart_qty</span><span class="p">,</span> <span class="n">subpart_part</span> <span class="o">=</span> <span class="n">manf_code_qtypart</span><span class="p">(</span><span class="n">p_manf_code</span><span class="p">)</span>
                            
                            <span class="c1"># Warning the user about different quantities signed to different `manf#`</span>
                            <span class="c1"># and catalogue number of same part/subpart. Which may be a type error by</span>
                            <span class="c1"># the user.</span>
                            <span class="k">if</span> <span class="n">p_manf_code</span> <span class="ow">and</span> <span class="n">p_manf_code_prior</span> <span class="ow">and</span> <span class="n">subpart_qty_prior</span><span class="o">!=</span><span class="n">subpart_qty</span><span class="p">:</span>
                                <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s1">&#39;Different quantities signed between </span><span class="se">\&quot;</span><span class="si">{f}</span><span class="s1">=</span><span class="si">{c}</span><span class="se">\&quot;</span><span class="s1"> and </span><span class="se">\&quot;</span><span class="si">{fl}</span><span class="s1">=</span><span class="si">{cl}</span><span class="se">\&quot;</span><span class="s1"> at </span><span class="se">\&quot;</span><span class="si">{r}</span><span class="se">\&quot;</span><span class="s1">. Make sure that is right.&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                                                    <span class="n">f</span><span class="o">=</span><span class="n">field_manf_dist_code</span><span class="p">,</span> <span class="n">fl</span><span class="o">=</span><span class="n">field_manf_dist_code_prior</span><span class="p">,</span>
                                                    <span class="n">c</span><span class="o">=</span><span class="n">p_manf_code</span><span class="p">,</span> <span class="n">cl</span><span class="o">=</span><span class="n">p_manf_code_prior</span><span class="p">,</span>
                                                    <span class="n">q</span><span class="o">=</span><span class="n">subpart_qty</span><span class="p">,</span> <span class="n">ql</span><span class="o">=</span><span class="n">subpart_qty_prior</span><span class="p">,</span>
                                                    <span class="n">r</span><span class="o">=</span><span class="n">order_refs</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">components</span><span class="o">.</span><span class="n">keys</span><span class="p">()))</span>
                                                <span class="p">))</span>
                            <span class="n">subpart_qty_prior</span> <span class="o">=</span> <span class="n">subpart_qty</span>
                            <span class="n">p_manf_code_prior</span> <span class="o">=</span> <span class="n">p_manf_code</span>
                            <span class="n">field_manf_dist_code_prior</span> <span class="o">=</span> <span class="n">field_manf_dist_code</span>
                            
                            <span class="n">subpart_actual</span><span class="p">[</span><span class="n">field_manf_dist_code</span><span class="p">]</span> <span class="o">=</span> <span class="n">subpart_part</span>
                            <span class="n">subpart_actual</span><span class="p">[</span><span class="n">field_manf_dist_code</span><span class="o">+</span><span class="s1">&#39;_qty&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">subpart_qty</span>
                            <span class="n">logger</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">DEBUG_OBSESSIVE</span><span class="p">,</span> <span class="n">subpart_actual</span><span class="p">)</span>
                        <span class="k">except</span> <span class="ne">IndexError</span><span class="p">:</span>
                            <span class="k">pass</span>
                    <span class="c1"># Update the split `manf`(manufactures names).</span>
                    <span class="k">if</span> <span class="n">subparts_manf</span><span class="p">[</span><span class="n">subparts_index</span><span class="p">]</span><span class="o">!=</span><span class="n">REPLICATE_MANF</span><span class="p">:</span>
                        <span class="c1"># If the actual manufacture name is the defined as `REPLICATE_MANF`</span>
                        <span class="c1"># replicate the last one.</span>
                        <span class="n">p_manf</span> <span class="o">=</span> <span class="n">subparts_manf</span><span class="p">[</span><span class="n">subparts_index</span><span class="p">]</span>
                    <span class="n">subpart_actual</span><span class="p">[</span><span class="s1">&#39;manf&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">p_manf</span>
                    <span class="c1"># Update the description and reference of the part.</span>
                    <span class="n">ref</span> <span class="o">=</span> <span class="n">part_ref</span> <span class="o">+</span> <span class="n">SUB_SEPRTR</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">subparts_index</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
                    <span class="n">split_components</span><span class="p">[</span><span class="n">ref</span><span class="p">]</span> <span class="o">=</span> <span class="n">subpart_actual</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">part_actual</span> <span class="o">=</span> <span class="n">part</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
                <span class="n">part_qty_prior</span> <span class="o">=</span> <span class="p">[]</span> <span class="c1"># Use this last cycle variable to warning the user about</span>
                <span class="n">p_manf_code_prior</span> <span class="o">=</span> <span class="p">[]</span> <span class="c1"># different quantities in the fields `manf#` and `cat#`.</span>
                <span class="n">field_manf_dist_code_prior</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">for</span> <span class="n">field_manf_dist_code</span> <span class="ow">in</span> <span class="n">founded_fields</span><span class="p">:</span>
                    <span class="c1"># When one &quot;single subpart&quot; also use the logic of quantity.</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="n">p_manf_code</span> <span class="o">=</span> <span class="n">subparts_manf_code</span><span class="p">[</span><span class="n">field_manf_dist_code</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
                        <span class="n">part_qty</span><span class="p">,</span> <span class="n">part_part</span> <span class="o">=</span> <span class="n">manf_code_qtypart</span><span class="p">(</span><span class="n">p_manf_code</span><span class="p">)</span>
                        
                        <span class="c1"># Warning the user about different quantities signed to different `manf#`</span>
                        <span class="c1"># and catalogue number of same part/subpart. Which may be a type error by</span>
                        <span class="c1"># the user.</span>
                        <span class="k">if</span> <span class="n">p_manf_code</span> <span class="ow">and</span> <span class="n">p_manf_code_prior</span> <span class="ow">and</span> <span class="n">part_qty_prior</span><span class="o">!=</span><span class="n">part_qty</span><span class="p">:</span>
                            <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s1">&#39;Different quantities signed between </span><span class="se">\&quot;</span><span class="si">{f}</span><span class="s1">=</span><span class="si">{c}</span><span class="se">\&quot;</span><span class="s1"> and </span><span class="se">\&quot;</span><span class="si">{fl}</span><span class="s1">=</span><span class="si">{cl}</span><span class="se">\&quot;</span><span class="s1"> at </span><span class="se">\&quot;</span><span class="si">{r}</span><span class="se">\&quot;</span><span class="s1">. Make sure that is right.&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                                                <span class="n">f</span><span class="o">=</span><span class="n">field_manf_dist_code</span><span class="p">,</span> <span class="n">fl</span><span class="o">=</span><span class="n">field_manf_dist_code_prior</span><span class="p">,</span>
                                                <span class="n">c</span><span class="o">=</span><span class="n">p_manf_code</span><span class="p">,</span> <span class="n">cl</span><span class="o">=</span><span class="n">p_manf_code_prior</span><span class="p">,</span>
                                                <span class="n">q</span><span class="o">=</span><span class="n">part_qty</span><span class="p">,</span> <span class="n">ql</span><span class="o">=</span><span class="n">part_qty_prior</span><span class="p">,</span>
                                                <span class="n">r</span><span class="o">=</span><span class="n">order_refs</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">components</span><span class="o">.</span><span class="n">keys</span><span class="p">()))</span>
                                            <span class="p">))</span>
                        <span class="n">part_qty_prior</span> <span class="o">=</span> <span class="n">part_qty</span>
                        <span class="n">p_manf_code_prior</span> <span class="o">=</span> <span class="n">p_manf_code</span>
                        <span class="n">field_manf_dist_code_prior</span> <span class="o">=</span> <span class="n">field_manf_dist_code</span>
                        
                        <span class="n">part_actual</span><span class="p">[</span><span class="n">field_manf_dist_code</span><span class="p">]</span> <span class="o">=</span> <span class="n">part_part</span>
                        <span class="n">part_actual</span><span class="p">[</span><span class="n">field_manf_dist_code</span><span class="o">+</span><span class="s1">&#39;_qty&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">part_qty</span>
                        <span class="n">logger</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">DEBUG_OBSESSIVE</span><span class="p">,</span> <span class="n">part</span><span class="p">)</span>
                        <span class="n">split_components</span><span class="p">[</span><span class="n">part_ref</span><span class="p">]</span> <span class="o">=</span> <span class="n">part_actual</span>
                    <span class="k">except</span> <span class="ne">IndexError</span><span class="p">:</span>
                        <span class="k">pass</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
            <span class="k">continue</span>

    <span class="k">return</span> <span class="n">split_components</span></div>


<div class="viewcode-block" id="partgroup_qty"><a class="viewcode-back" href="../../../kicost.edas.html#kicost.edas.tools.partgroup_qty">[docs]</a><span class="k">def</span> <span class="nf">partgroup_qty</span><span class="p">(</span><span class="n">component</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;@brief Take the components grouped quantity.</span>
<span class="sd">       </span>
<span class="sd">       Calculate the string of the quantity of the group parsing the</span>
<span class="sd">       reference (design) quantity and the sub quantity (in case that</span>
<span class="sd">       was a sub part of a manufacture/distributor code).</span>
<span class="sd">       In the case of the multifiles BOM (and future revision of the</span>
<span class="sd">       code) just use the &#39;manf#_qty&#39; field that in `group_parts()`</span>
<span class="sd">       recorded the quantities used in each project.</span>
<span class="sd">       </span>
<span class="sd">       @param components Part component `dict()`, format given by the EDA modules.</span>
<span class="sd">       @return Quantity of the manf# part used.</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">qty</span> <span class="o">=</span> <span class="n">component</span><span class="o">.</span><span class="n">fields</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;manf#_qty&#39;</span><span class="p">)</span>

        <span class="n">logger</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">DEBUG_OBSESSIVE</span><span class="p">,</span> <span class="s1">&#39;Qty&gt;&gt; </span><span class="si">{}</span><span class="se">\t</span><span class="s1"> </span><span class="si">{}</span><span class="s1">*</span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">component</span><span class="o">.</span><span class="n">refs</span><span class="p">,</span> <span class="n">qty</span><span class="p">,</span> <span class="n">component</span><span class="o">.</span><span class="n">fields</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;manf#&#39;</span><span class="p">))</span> <span class="p">)</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">qty</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="c1"># Multifiles BOM case, the quantities in the list represent</span>
            <span class="c1"># each project read by the order. Do not `CEILING` because</span>
            <span class="c1"># this is will be made in the total columns that sum all</span>
            <span class="c1"># the quantities needed in all projects BOMs.</span>
            <span class="n">string</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;={{}}*(</span><span class="si">{qp}</span><span class="s1">)&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">qp</span><span class="o">=</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">qty</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">qty</span> <span class="o">!=</span> <span class="s1">&#39;1&#39;</span> <span class="ow">and</span> <span class="n">qty</span> <span class="o">!=</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">string</span> <span class="o">=</span> <span class="s1">&#39;=CEILING({{}}*(</span><span class="si">{q}</span><span class="s1">)*</span><span class="si">{qty}</span><span class="s1">,1)&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                                <span class="n">q</span><span class="o">=</span><span class="n">qty</span><span class="p">,</span>
                                <span class="n">qty</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">component</span><span class="o">.</span><span class="n">refs</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">string</span> <span class="o">=</span> <span class="s1">&#39;={{}}*</span><span class="si">{qty}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">qty</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">component</span><span class="o">.</span><span class="n">refs</span><span class="p">))</span>
    <span class="k">except</span> <span class="p">(</span><span class="ne">KeyError</span><span class="p">,</span> <span class="ne">TypeError</span><span class="p">):</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">DEBUG_OBSESSIVE</span><span class="p">,</span> <span class="s1">&#39;Qty&gt;&gt; </span><span class="si">{}</span><span class="s1"> </span><span class="se">\t</span><span class="s1"> </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">component</span><span class="o">.</span><span class="n">refs</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">component</span><span class="o">.</span><span class="n">refs</span><span class="p">))</span> <span class="p">)</span>
        <span class="n">string</span> <span class="o">=</span> <span class="s1">&#39;={{}}*</span><span class="si">{qty}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">qty</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">component</span><span class="o">.</span><span class="n">refs</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">string</span></div>


<span class="k">def</span> <span class="nf">subpart_list</span><span class="p">(</span><span class="n">part</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    @brief Split the subpart by the `PART_SEPRTR`definition.</span>
<span class="sd">    </span>
<span class="sd">    Get the list of sub parts manufacture / distributor code</span>
<span class="sd">    numbers stripping the spaces and keeping the sub part</span>
<span class="sd">    quantity information, these have to be separated by</span>
<span class="sd">    PART_SEPRTR definition.</span>
<span class="sd">    </span>
<span class="sd">    @param part Manufacture code part `str`.</span>
<span class="sd">    @return List of manufacture code parts.</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="k">return</span> <span class="n">re</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">PART_SEPRTR</span><span class="p">,</span> <span class="n">part</span><span class="o">.</span><span class="n">strip</span><span class="p">())</span>


<span class="k">def</span> <span class="nf">manf_code_qtypart</span><span class="p">(</span><span class="n">subpart</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;@brief Get the quantity and the part code of the sub part</span>
<span class="sd">       manufacture / distributor. Test if was pre or post</span>
<span class="sd">       multiplied by a constant.</span>
<span class="sd">       </span>
<span class="sd">       Setting QTY_SEPRTR as &#39;\:&#39;, we have</span>
<span class="sd">       &#39; 4.5 : ADUM3150BRSZ-RL7&#39; -&gt; (&#39;4.5&#39;, &#39;ADUM3150BRSZ-RL7&#39;)</span>
<span class="sd">       &#39;4/5  : ADUM3150BRSZ-RL7&#39; -&gt; (&#39;4/5&#39;, &#39;ADUM3150BRSZ-RL7&#39;)</span>
<span class="sd">       &#39;7:ADUM3150BRSZ-RL7&#39; -&gt; (&#39;7&#39;, &#39;ADUM3150BRSZ-RL7&#39;)</span>
<span class="sd">       &#39;ADUM3150BRSZ-RL7 :   7&#39; -&gt; (&#39;7&#39;, &#39;ADUM3150BRSZ-RL7&#39;)</span>
<span class="sd">       &#39;ADUM3150BRSZ-RL7&#39; -&gt; (&#39;1&#39;, &#39;ADUM3150BRSZ-RL7&#39;)</span>
<span class="sd">       &#39;ADUM3150BRSZ-RL7:&#39; -&gt; (&#39;1&#39;, &#39;ADUM3150BRSZ-RL7&#39;) forgot the qty understood &#39;1&#39;</span>
<span class="sd">       </span>
<span class="sd">       @param Part that way have different than ONE quantity. Intended as one element of the list of `subpart_list()`.</span>
<span class="sd">       @return (qty, manf#) Quantity and the manufacture code.</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">subpart</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="n">ESC_FIND</span><span class="p">,</span> <span class="sa">r</span><span class="s1">&#39;\1&#39;</span><span class="p">,</span> <span class="n">subpart</span><span class="p">)</span> <span class="c1"># Remove any escape backslashes preceding PART_SEPRTR.</span>
    <span class="n">strings</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">QTY_SEPRTR</span><span class="p">,</span> <span class="n">subpart</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">strings</span><span class="p">)</span><span class="o">==</span><span class="mi">2</span><span class="p">:</span>
        <span class="c1"># Search for numbers, matching with simple, frac and decimal ones.</span>
        <span class="n">num_format</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="s2">&quot;^\s*[\-\+]?\s*[0-9]*\s*[\.\/]*\s*?[0-9]*\s*$&quot;</span><span class="p">)</span>
        <span class="n">string0_test</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">num_format</span><span class="p">,</span> <span class="n">strings</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">string1_test</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">num_format</span><span class="p">,</span> <span class="n">strings</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">string0_test</span> <span class="ow">and</span> <span class="ow">not</span><span class="p">(</span><span class="n">string1_test</span><span class="p">):</span>
            <span class="n">qty</span> <span class="o">=</span> <span class="n">strings</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
            <span class="n">part</span> <span class="o">=</span> <span class="n">strings</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
        <span class="k">elif</span> <span class="ow">not</span><span class="p">(</span><span class="n">string0_test</span><span class="p">)</span> <span class="ow">and</span> <span class="n">string1_test</span><span class="p">:</span>
            <span class="n">qty</span> <span class="o">=</span> <span class="n">strings</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
            <span class="n">part</span> <span class="o">=</span> <span class="n">strings</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
        <span class="k">elif</span> <span class="n">string0_test</span> <span class="ow">and</span> <span class="n">string1_test</span><span class="p">:</span>
            <span class="c1"># May be founded a just numeric manufacture/distributor part,</span>
            <span class="c1"># in this case, the quantity is a shortest string not</span>
            <span class="c1">#considering &quot;.&quot; and &quot;/&quot; marks.</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">re</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="s1">&#39;[\.\/]&#39;</span><span class="p">,</span><span class="s1">&#39;&#39;</span><span class="p">,</span><span class="n">strings</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">re</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="s1">&#39;[\.\/]&#39;</span><span class="p">,</span><span class="s1">&#39;&#39;</span><span class="p">,</span><span class="n">strings</span><span class="p">[</span><span class="mi">1</span><span class="p">])):</span>
                <span class="n">qty</span> <span class="o">=</span> <span class="n">strings</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
                <span class="n">part</span> <span class="o">=</span> <span class="n">strings</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">qty</span> <span class="o">=</span> <span class="n">strings</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
                <span class="n">part</span> <span class="o">=</span> <span class="n">strings</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">qty</span> <span class="o">=</span> <span class="s1">&#39;1&#39;</span>
            <span class="n">part</span> <span class="o">=</span> <span class="n">strings</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span> <span class="o">+</span> <span class="n">strings</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">qty</span><span class="o">==</span><span class="s1">&#39;&#39;</span><span class="p">:</span>
            <span class="n">qty</span> <span class="o">=</span> <span class="s1">&#39;1&#39;</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">qty</span> <span class="o">=</span> <span class="s1">&#39;1&#39;</span>
        <span class="n">part</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">strings</span><span class="p">)</span>
    <span class="n">logger</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">DEBUG_OBSESSIVE</span><span class="p">,</span> <span class="s1">&#39;part/qty&gt;&gt; </span><span class="si">{}</span><span class="se">\t\t</span><span class="s1">part&gt;&gt;</span><span class="si">{}</span><span class="se">\t</span><span class="s1">qty&gt;&gt;&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">subpart</span><span class="p">,</span> <span class="n">part</span><span class="p">,</span> <span class="n">qty</span><span class="p">)</span> <span class="p">)</span>
    <span class="k">return</span> <span class="n">qty</span><span class="p">,</span> <span class="n">part</span>


<div class="viewcode-block" id="order_refs"><a class="viewcode-back" href="../../../kicost.edas.html#kicost.edas.tools.order_refs">[docs]</a><span class="k">def</span> <span class="nf">order_refs</span><span class="p">(</span><span class="n">refs</span><span class="p">,</span> <span class="n">collapse</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;@brief Collapse list of part references into a sorted, comma-separated list of hyphenated ranges. This is intended as opposite of `split_refs()`</span>
<span class="sd">       @param refs Designator/references `list()`.</span>
<span class="sd">       @return References in a organized view way.</span>
<span class="sd">    &#39;&#39;&#39;</span>

    <span class="k">def</span> <span class="nf">convert_to_ranges</span><span class="p">(</span><span class="n">nums</span><span class="p">):</span>
        <span class="c1"># Collapse a list of numbers into sorted, comma-separated, hyphenated ranges.</span>
        <span class="c1"># e.g.: 3,4,7,8,9,10,11,13,14 =&gt; 3,4,7-11,13,14</span>

        <span class="k">def</span> <span class="nf">get_refnum</span><span class="p">(</span><span class="n">refnum</span><span class="p">):</span>
            <span class="k">return</span> <span class="nb">int</span><span class="p">(</span><span class="n">re</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="s1">&#39;\d+&#39;</span><span class="p">,</span> <span class="n">refnum</span><span class="p">)</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span>

        <span class="k">def</span> <span class="nf">to_int</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="k">return</span> <span class="nb">int</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">n</span>

        <span class="n">nums</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="n">get_refnum</span><span class="p">)</span>  <span class="c1"># Sort all the numbers.</span>
        <span class="n">nums</span> <span class="o">=</span> <span class="p">[</span><span class="n">to_int</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">nums</span><span class="p">]</span>  <span class="c1"># Convert strings to `int` if possible.</span>
        <span class="n">num_ranges</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># No ranges found yet since we just started.</span>
        <span class="n">range_start</span> <span class="o">=</span> <span class="mi">0</span>  <span class="c1"># First possible range is at the start of the list of numbers.</span>

        <span class="c1"># Go through the list of numbers looking for 3 or more sequential numbers.</span>
        <span class="k">while</span> <span class="n">range_start</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">nums</span><span class="p">):</span>
            <span class="n">num_range</span> <span class="o">=</span> <span class="n">nums</span><span class="p">[</span><span class="n">range_start</span><span class="p">]</span>  <span class="c1"># Current range starts off as a single number.</span>
            <span class="n">next_range_start</span> <span class="o">=</span> <span class="n">range_start</span> <span class="o">+</span> <span class="mi">1</span>  <span class="c1"># The next possible start of a range.</span>
            <span class="c1"># Part references with subparts are never included in ref ranges.</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">num_range</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
                <span class="n">num_ranges</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">num_range</span><span class="p">)</span>
                <span class="n">range_start</span> <span class="o">=</span> <span class="n">next_range_start</span>
                <span class="k">continue</span>
            <span class="c1"># Look for sequences of three or more sequential numbers.</span>
            <span class="k">for</span> <span class="n">range_end</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">range_start</span> <span class="o">+</span> <span class="mi">2</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">nums</span><span class="p">)):</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">nums</span><span class="p">[</span><span class="n">range_end</span><span class="p">],</span> <span class="nb">int</span><span class="p">):</span>
                    <span class="k">break</span>  <span class="c1"># Ref with subpart, so can&#39;t be in a ref range.</span>
                <span class="k">if</span> <span class="n">range_end</span> <span class="o">-</span> <span class="n">range_start</span> <span class="o">!=</span> <span class="n">nums</span><span class="p">[</span><span class="n">range_end</span><span class="p">]</span> <span class="o">-</span> <span class="n">nums</span><span class="p">[</span><span class="n">range_start</span><span class="p">]:</span>
                    <span class="k">break</span>  <span class="c1"># Non-sequential numbers found, so break out of loop.</span>
                <span class="c1"># Otherwise, extend the current range.</span>
                <span class="n">num_range</span> <span class="o">=</span> <span class="p">[</span><span class="n">nums</span><span class="p">[</span><span class="n">range_start</span><span class="p">],</span> <span class="n">nums</span><span class="p">[</span><span class="n">range_end</span><span class="p">]]</span>
                <span class="c1"># 3 or more sequential numbers found, so next possible range must start after this one.</span>
                <span class="n">next_range_start</span> <span class="o">=</span> <span class="n">range_end</span> <span class="o">+</span> <span class="mi">1</span>
            <span class="c1"># Append the range (or single number) just found to the list of range.</span>
            <span class="n">num_ranges</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">num_range</span><span class="p">)</span>
            <span class="c1"># Point to the start of the next possible range and keep looking.</span>
            <span class="n">range_start</span> <span class="o">=</span> <span class="n">next_range_start</span>

        <span class="k">return</span> <span class="n">num_ranges</span>

    <span class="n">prefix_nums</span> <span class="o">=</span> <span class="p">{}</span>  <span class="c1"># Contains a list of numbers for each distinct prefix.</span>
    <span class="k">for</span> <span class="n">ref</span> <span class="ow">in</span> <span class="n">refs</span><span class="p">:</span>
        <span class="c1"># Partition each part reference into its beginning part prefix and ending number.</span>
        <span class="n">match</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="n">PART_REF_REGEX</span><span class="p">,</span> <span class="n">ref</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">match</span><span class="p">:</span>
            <span class="n">prefix</span> <span class="o">=</span> <span class="n">match</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="s1">&#39;prefix&#39;</span><span class="p">)</span>
            <span class="n">num</span> <span class="o">=</span> <span class="n">match</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="s1">&#39;num&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># The not `match` happens when the user schematic designer use</span>
            <span class="c1"># not recognized characters by the `PART_REF_REGEX` definition</span>
            <span class="c1"># into the components references.</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Not recognized characters used in &lt;&#39;</span> <span class="o">+</span> <span class="n">ref</span> <span class="o">+</span> <span class="s1">&#39;&gt; reference. Advise: edit it in your BOM/Schematic.&#39;</span><span class="p">)</span>

        <span class="c1"># Append the number to the list of numbers for this prefix, or create a list</span>
        <span class="c1"># with a single number if this is the first time a particular prefix was encountered.</span>
        <span class="n">prefix_nums</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="n">prefix</span><span class="p">,</span> <span class="p">[])</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">num</span><span class="p">)</span>

    <span class="c1"># Convert the list of numbers for each ref prefix into ranges.</span>
    <span class="k">if</span> <span class="n">collapse</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">prefix</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="n">prefix_nums</span><span class="o">.</span><span class="n">keys</span><span class="p">()):</span>
            <span class="n">prefix_nums</span><span class="p">[</span><span class="n">prefix</span><span class="p">]</span> <span class="o">=</span> <span class="n">convert_to_ranges</span><span class="p">(</span><span class="n">prefix_nums</span><span class="p">[</span><span class="n">prefix</span><span class="p">])</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">prefix</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="n">prefix_nums</span><span class="o">.</span><span class="n">keys</span><span class="p">()):</span>
            <span class="k">def</span> <span class="nf">get_refnum</span><span class="p">(</span><span class="n">refnum</span><span class="p">):</span>
                <span class="k">return</span> <span class="nb">int</span><span class="p">(</span><span class="n">re</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="s1">&#39;\d+&#39;</span><span class="p">,</span> <span class="n">refnum</span><span class="p">)</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span>
            <span class="n">prefix_nums</span><span class="p">[</span><span class="n">prefix</span><span class="p">]</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="n">get_refnum</span><span class="p">)</span>

    <span class="c1"># Combine the prefixes and number ranges back into part references.</span>
    <span class="n">collapsed_refs</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">prefix</span><span class="p">,</span> <span class="n">nums</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="n">prefix_nums</span><span class="o">.</span><span class="n">items</span><span class="p">()):</span>
        <span class="k">for</span> <span class="n">num</span> <span class="ow">in</span> <span class="n">nums</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">num</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
                <span class="c1"># Convert a range list into a collapsed part reference:</span>
                <span class="c1"># e.g., &#39;R10-R15&#39; from &#39;R&#39;:[10,15].</span>
                <span class="n">collapsed_refs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">{0}{1}{3}{0}{2}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">prefix</span><span class="p">,</span> <span class="n">num</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">num</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">PART_SEQ_SEPRTR</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Convert a single number into a simple part reference: e.g., &#39;R10&#39;.</span>
                <span class="n">collapsed_refs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">{}{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">prefix</span><span class="p">,</span> <span class="n">num</span><span class="p">))</span>

    <span class="n">collapsed_refs</span> <span class="o">=</span> <span class="n">PART_NSEQ_SEPRTR</span><span class="o">.</span><span class="n">join</span><span class="p">(</span> <span class="n">collapsed_refs</span> <span class="p">)</span>
    <span class="k">return</span> <span class="n">collapsed_refs</span> <span class="c1"># Return the collapsed par references.</span></div>


<span class="k">def</span> <span class="nf">split_refs</span><span class="p">(</span><span class="n">text</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;@brief Split string grouped references into a unique designator. This is intended as opposite of `order_refs(?, collapse=True)`</span>
<span class="sd">       </span>
<span class="sd">       &#39;C17/18/19/20&#39; --&gt; [&#39;C17&#39;,&#39;C18&#39;,&#39;C19&#39;,&#39;C20&#39;]</span>
<span class="sd">       &#39;C17\18\19\20&#39; --&gt; [&#39;C17&#39;,&#39;C18&#39;,&#39;C19&#39;,&#39;C20&#39;]</span>
<span class="sd">       &#39;D33-D36&#39; --&gt; [&#39;D33&#39;,&#39;D34&#39;,&#39;D35&#39;,&#39;D36&#39;]</span>
<span class="sd">       &#39;D33-36&#39; --&gt; [&#39;D33&#39;,&#39;D34&#39;,&#39;D35&#39;,&#39;D36&#39;]</span>
<span class="sd">       Also ignore some characters as &#39;.&#39; or &#39;:&#39; used in some cases of references.</span>
<span class="sd">       </span>
<span class="sd">       @param text Designator/references worn by a group of parts.</span>
<span class="sd">       @return Designator/references `list()` split.</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">partial_ref</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39; *[,; ] *&#39;</span><span class="p">,</span> <span class="n">text</span><span class="p">)</span> <span class="c1"># Split ignoring the spaces.</span>
    <span class="n">refs</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">ref</span> <span class="ow">in</span> <span class="n">partial_ref</span><span class="p">:</span>
        <span class="c1"># Remove invalid characters. Changed `PART_REF_REGEX_SPECIAL_CHAR_REF` definition and allowed special characters.</span>
        <span class="c1">#ref = re.sub(&#39;\+$&#39;, &#39;p&#39;, ref) # Finishing &quot;+&quot;.</span>
        <span class="n">ref</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="n">PART_REF_REGEX_NOT_ALLOWED</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">ref</span><span class="p">)</span> <span class="c1"># Generic special characters not allowed. To work around #ISSUE #89.</span>
        <span class="c1">#ref = re.sub(&#39;\-+&#39;, &#39;-&#39;, ref) # Double &quot;-&quot;.</span>
        <span class="c1">#ref = re.sub(&#39;^\-&#39;, &#39;&#39;, ref) # Starting &quot;-&quot;.</span>
        <span class="c1">#ref = re.sub(&#39;\-$&#39;, &#39;n&#39;, ref) # Finishing &quot;-&quot;.</span>
        <span class="k">if</span> <span class="n">re</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="s1">&#39;^\w+\d&#39;</span><span class="p">,</span> <span class="n">ref</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">re</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="s1">&#39;-&#39;</span><span class="p">,</span> <span class="n">ref</span><span class="p">):</span>
                <span class="n">designator_name</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">findall</span><span class="p">(</span><span class="s1">&#39;^\D+&#39;</span><span class="p">,</span> <span class="n">ref</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">split_nums</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;-&#39;</span><span class="p">,</span> <span class="n">ref</span><span class="p">)</span>
                <span class="n">designator_name</span> <span class="o">+=</span> <span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span> <span class="n">re</span><span class="o">.</span><span class="n">findall</span><span class="p">(</span><span class="s1">&#39;^d*\W&#39;</span><span class="p">,</span> <span class="n">split_nums</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="p">)</span> <span class="p">)</span>
                <span class="n">split_nums</span> <span class="o">=</span> <span class="p">[</span><span class="n">re</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="n">designator_name</span><span class="p">,</span><span class="s1">&#39;&#39;</span><span class="p">,</span><span class="n">split_nums</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">split_nums</span><span class="p">))]</span>
                
                <span class="c1"># Some EDAs may use some separator in the reference numeric parts, as</span>
                <span class="c1"># Altium that use &quot;.&quot; (or even other) e.g. &quot;R2.1,R2.2&quot; to the same &quot;R2&quot;</span>
                <span class="c1"># replicated between schematics / rooms.</span>
                <span class="n">base_split_nums</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span> <span class="n">re</span><span class="o">.</span><span class="n">findall</span><span class="p">(</span><span class="s1">&#39;^\d+\D&#39;</span><span class="p">,</span> <span class="n">split_nums</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="p">)</span>
                <span class="n">split_nums</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span> <span class="n">re</span><span class="o">.</span><span class="n">findall</span><span class="p">(</span><span class="s1">&#39;\D*(\d+)$&#39;</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span> <span class="p">)</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">split_nums</span><span class="p">]</span>
                
                <span class="n">split</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span> <span class="nb">range</span><span class="p">(</span> <span class="nb">int</span><span class="p">(</span><span class="n">split_nums</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="nb">int</span><span class="p">(</span><span class="n">split_nums</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span><span class="o">+</span><span class="mi">1</span> <span class="p">)</span> <span class="p">)</span>
                <span class="c1">#split = [designator_name+str(split[i]) for i in range(len(split)) ]</span>
                <span class="n">split</span> <span class="o">=</span> <span class="p">[</span><span class="n">designator_name</span> <span class="o">+</span><span class="n">base_split_nums</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">split</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">split</span><span class="p">))</span> <span class="p">]</span>
                
                <span class="n">refs</span> <span class="o">+=</span> <span class="n">split</span>
            <span class="k">elif</span> <span class="n">re</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="s1">&#39;[/</span><span class="se">\\</span><span class="s1">\]&#39;</span><span class="p">,</span> <span class="n">ref</span><span class="p">):</span>
                <span class="n">designator_name</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">findall</span><span class="p">(</span><span class="s1">&#39;^\D+&#39;</span><span class="p">,</span><span class="n">ref</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">split_nums</span> <span class="o">=</span> <span class="p">[</span><span class="n">re</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="s1">&#39;^&#39;</span><span class="o">+</span><span class="n">designator_name</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">re</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;[/</span><span class="se">\\</span><span class="s1">\]&#39;</span><span class="p">,</span><span class="n">ref</span><span class="p">)]</span>
                <span class="n">refs</span> <span class="o">+=</span> <span class="p">[</span><span class="n">designator_name</span><span class="o">+</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">split_nums</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">refs</span> <span class="o">+=</span> <span class="p">[</span><span class="n">ref</span><span class="o">.</span><span class="n">strip</span><span class="p">()]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># The designator name is not for a group of components and </span>
            <span class="c1"># &quot;\&quot;, &quot;/&quot; or &quot;-&quot; is part of the name. This characters have</span>
            <span class="c1"># to be removed.</span>
            <span class="n">ref</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="s1">&#39;[\-\/</span><span class="se">\\</span><span class="s1">\]&#39;</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">ref</span><span class="o">.</span><span class="n">strip</span><span class="p">())</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">re</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="n">PART_REF_REGEX</span><span class="p">,</span> <span class="n">ref</span><span class="p">)</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="s1">&#39;num&#39;</span><span class="p">):</span>
                <span class="c1"># Add a &#39;0&#39; number at the end to be compatible with KiCad/KiCost</span>
                <span class="c1"># ref strings. This may be missing in the hand made BoM.</span>
                <span class="n">ref</span> <span class="o">+=</span> <span class="s1">&#39;0&#39;</span>
            <span class="n">refs</span> <span class="o">+=</span> <span class="p">[</span><span class="n">ref</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">refs</span>
</pre></div>

          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../../index.html">kicost 1.1.3 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../../index.html" >Module code</a> &#187;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2015, XESS Corporation.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 2.1.2.
    </div>
  </body>
</html>